package net.resheim.eclipse.cc.vice.debug;

/**
 * Various constants related to the VICE Binary Monitor.
 *
 * @since 1.0
 * @author Torkild Ulv√∏y Resheim
 */
public interface IBinaryMonitor {

	public final byte[] EMPTY_COMMAND_BODY = {};
	/**
	 * A debug event detail notifying listeners that the computer memory has been
	 * updated and a new disassembly should be executed.
	 */
	public final int DISASSEMBLE = 99;

	public enum Response {
		/**
		 * This response type is returned for errors.
		 * <p>
		 * Response code: <b><code>0x00</code></b>
		 * <p>
		 */
		INVALID((byte) 0x00),
		/**
		 * Register repsponse, is returned after any command issued
		 * <p>
		 * Response code: <b><code>0x31</code></b>
		 * <p>
		 */
		REGISTER_INFO((byte) 0x31),
		/**
		 * When the CPU jams
		 * <p>
		 * Response code: <b><code>0x61</code></b>
		 * <p>
		 */
		RESPONSE_JAM((byte) 0x61),
		/**
		 * When the machine stops for the monitor, either due to hitting a checkpoint or
		 * stepping.
		 * <p>
		 * Response code: <b><code>0x62</code></b>
		 * <p>
		 */
		STOPPED((byte) 0x62),
		/**
		 * When the machine resumes execution for any reason.
		 * <p>
		 * Response code: <b><code>0x63</code></b>
		 * <p>
		 */
		RESUMED((byte) 0x63),
		/**
		 * This response is generated by hitting a checkpoint, or by many of the
		 * checkpoint commands.
		 * <p>
		 * Response code: <b><code>0x11</code></b>
		 * <p>
		 */
		CHECKPOINT_INFO((byte) 0x11);

		private final byte code;

		Response(byte code) {
			this.code = code;
		}

		public byte getCode() {
			return this.code;
		}

		public static String getNameFromCode(byte code) {
			for (Response cmd : Response.values()) {
				if (cmd.getCode() == code) {
					return cmd.name();
				}
			}
			return "Unknown response";
		}

		public static boolean hasCode(byte code) {
			for (Response cmd : Response.values()) {
				if (cmd.getCode() == code) {
					return true;
				}
			}
			return false;
		}

	}

	public enum MemoryType {
		Default((byte) 0), Cpu((byte) 1), Ram((byte) 2), Rom((byte) 3), Io((byte) 4), Cartridge((byte) 5);

		public final byte type;

		private MemoryType(byte type) {
			this.type = type;
		}
	};

	public enum Command {
		/**
		 * Reads a chunk of memory from a start address to an end address (inclusive).
		 * <p>
		 * Command code: <b><code>0x01</code></b>
		 * <p>
		 */
		MEMORY_GET((byte) 0x01),
		/**
		 * Writes a chunk of memory from a start address to an end address (inclusive)
		 * <p>
		 * Command code: <b><code>0x02</code></b>
		 * <p>
		 */
		MEMORY_SET((byte) 0x02),
		/**
		 * Gets any type of checkpoint. (break, watch, trace)
		 * <p>
		 * Command code: <b><code>0x11</code></b>
		 * <p>
		 */
		CHECKPOINT_GET((byte) 0x11),
		/**
		 * Sets any type of checkpoint. This combines the functionality of several
		 * textual commands (break, watch, trace) into one, as they are all the same
		 * with only minor variations.
		 * <p>
		 * Command code: <b><code>0x12</code></b>
		 * <p>
		 */
		CHECKPOINT_SET((byte) 0x12),
		/**
		 * Deletes any type of checkpoint. (break, watch, trace).
		 * <p>
		 * Command code: <b><code>0x13</code></b>
		 * <p>
		 */
		CHECKPOINT_DELETE((byte) 0x13),
		/**
		 * Emits a series of MON RESPONSE CHECKPOINT INFO responses.
		 * <p>
		 * Command code: <b><code>0x14</code></b>
		 * <p>
		 */
		CHECKPOINT_LIST((byte) 0x14),
		/**
		 * Toggles the given checkpoint.
		 * <p>
		 * Command code: <b><code>0x15</code></b>
		 * <p>
		 */
		CHECKPOINT_TOGGLE((byte) 0x15),
		/**
		 * Sets a condition on an existing checkpoint. It is not currently possible to
		 * retrieve conditions after setting them.
		 * <p>
		 * Command code: <b><code>0x22</code></b>
		 * <p>
		 */
		CHECKPOINT_CONDITION_SET((byte) 0x22),
		/**
		 * Get details about the registers.
		 * <p>
		 * Command code: <b><code>0x31</code></b>
		 * <p>
		 */
		REGISTERS_GET((byte) 0x31),
		/**
		 * Set the register values.
		 * <p>
		 * Command code: <b><code>0x32</code></b>
		 * <p>
		 */
		REGISTERS_SET((byte) 0x32),
		/**
		 * Saves the machine state to a file.
		 * <p>
		 * Command code: <b><code>0x41</code></b>
		 * <p>
		 */
		DUMP((byte) 0x41),
		/**
		 * Loads the machine state from a file.
		 * <p>
		 * Command code: <b><code>0x42</code></b>
		 * <p>
		 */
		UNDUMP((byte) 0x42),
		/**
		 * Get a resource value from the emulator.
		 * <p>
		 * Command code: <b><code>0x51</code></b>
		 * <p>
		 */
		RESOURCE_GET((byte) 0x51),
		/**
		 * Set a resource value in the emulator.
		 * <p>
		 * Command code: <b><code>0x52</code></b>
		 * <p>
		 */
		RESOURCE_SET((byte) 0x52),
		/**
		 * Step over a certain number of instructions.
		 * <p>
		 * Command code: <b><code>0x71</code></b>
		 * <p>
		 */
		ADVANCE_INSTRUCTIONS((byte) 0x71),
		/**
		 * Add text to the keyboard buffer.
		 * <p>
		 * Command code: <b><code>0x72</code></b>
		 * <p>
		 */
		KEYBOARD_FEED((byte) 0x72),
		/**
		 * Continues execution and returns to the monitor just after the next RTS or RTI
		 * is executed.
		 * <p>
		 * Command code: <b><code>0x73</code></b>
		 * <p>
		 */
		EXECUTE_UNTIL_RETURN((byte) 0x73),
		/**
		 * Get an empty response. <i>Use for <code>SUSPEND</code> as any command
		 * submitted will cause the emulator to stop temporarily.</i>
		 * <p>
		 * Command code: <b><code>0x81</code></b>
		 * <p>
		 */
		PING((byte) 0x81),
		/**
		 * Gives a listing of all the bank IDs for the running machine with their names.
		 * <p>
		 * Command code: <b><code>0x82</code></b>
		 * <p>
		 */
		BANKS_AVAILABLE((byte) 0x82),
		/**
		 * Gives a listing of all the registers for the running machine with their
		 * names.
		 * <p>
		 * Command code: <b><code>0x83</code></b>
		 * <p>
		 */
		REGISTERS_AVAILABLE((byte) 0x83),
		/**
		 * Gets the current screen in a requested bit format.
		 * <p>
		 * Command code: <b><code>0x84</code></b>
		 * <p>
		 */
		DISPLAY_GET((byte) 0x84),
		/**
		 * Get general information about VICE. Currently returns the versions.
		 * <p>
		 * Command code: <b><code>0x85</code></b>
		 * <p>
		 */
		VICE_INFO((byte) 0x85),
		/**
		 * Get the colors in the current palette.
		 * <p>
		 * Command code: <b><code>0x91</code></b>
		 * <p>
		 */
		PALETTE_GET((byte) 0x91),
		/**
		 * Set the simulated joyport value.
		 * <p>
		 * Command code: <b><code>0xA2</code></b>
		 * <p>
		 */
		JOYPORT_SET((byte) 0xa2),
		/**
		 * Set the simulated userport value.
		 * <p>
		 * Command code: <b><code>0xB2</code></b>
		 * <p>
		 */
		USERPORT_SET((byte) 0xb2),
		/**
		 * Exit the monitor until the next breakpoint (RESUME)
		 * <p>
		 * Command code: <b><code>0xAA</code></b>
		 * <p>
		 */
		EXIT((byte) 0xaa),
		/**
		 * Quits VICE (TERMINATE)
		 * <p>
		 * Command code: <b><code>0xBB</code></b>
		 * <p>
		 */
		QUIT((byte) 0xbb),
		/**
		 * Reset the system or a drive
		 * <p>
		 * Command code: <b><code>0xCC</code></b>
		 * <p>
		 */
		RESET((byte) 0xcc),
		/**
		 * Load a program then return to the monitor
		 * <p>
		 * Command code: <b><code>0xDD</code></b>
		 * <p>
		 */
		AUTOSTART((byte) 0xdd);

		private final byte code;

		Command(byte code) {
			this.code = code;
		}

		public byte getCode() {
			return this.code;
		}

		public static String getNameFromCode(byte code) {
			for (Command cmd : Command.values()) {
				if (cmd.getCode() == code) {
					return cmd.name();
				}
			}
			return "Unknown command " + code;
		}

		public static boolean hasCode(byte code) {
			for (Command cmd : Command.values()) {
				if (cmd.getCode() == code) {
					return true;
				}
			}
			return false;
		}

	}
};
